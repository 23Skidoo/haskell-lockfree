
// ============================================================
// We only use this file for GHC 7.8+
// ============================================================

#include "Cmm.h"



// RRN: Uses the ticketed approach; see casMutVar
stg_casArray2zh ( gcptr arr, W_ ind, gcptr old, gcptr new )
/* MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, Any a #) */
{
    gcptr p, h;
    W_ len;

    p = arr + SIZEOF_StgMutArrPtrs + WDS(ind);
    (h) = ccall cas(p, old, new);
    
    if (h != old) {
        // Failure, return what was there instead of 'old':
        return (1,h);
    } else {
        // Compare and Swap Succeeded:
        SET_HDR(arr, stg_MUT_ARR_PTRS_DIRTY_info, CCCS);
        len = StgMutArrPtrs_ptrs(arr);
        // The write barrier.  We must write a byte into the mark table:
        I8[arr + SIZEOF_StgMutArrPtrs + WDS(len) + (ind >> MUT_ARR_PTRS_CARD_BITS )] = 1;
        return (0,new);
    }
}



// RRN: This one does not use the "ticketing" approach because it
// deals in unboxed scalars, not heap pointers.
// 
// This changed names to stg_casIntArrayzh when it was included with GHC 7.8.
stg_casByteArrayIntzh ( gcptr arr, W_ ind, W_ old, W_ new )
/* MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #) */
{
    gcptr p;
    W_ h;

    p = arr + SIZEOF_StgArrWords + WDS(ind);
    (h) = ccall cas(p, old, new);

    return(h);
}


// This changed names to stg_fetchAddIntArrayzh when it was included inside GHC 7.8.
stg_fetchAddByteArrayIntzh ( gcptr arr, W_ ind, W_ incr )
/* MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #) */
{
    gcptr p;
    W_ h;

    p = arr + SIZEOF_StgArrWords + WDS(ind);
    (h) = ccall atomic_inc(p, incr);

    return(h);
}


// RRN: To support the "ticketed" approach, we return the NEW rather
// than old value if the CAS is successful.  This is received in an
// opaque form in the Haskell code, preventing the compiler from
// changing its pointer identity.  The ticket can then be safely used
// in future CAS operations.
// 
// (Historical note: The old casMutVar# in GHC 7.2-7.6 returned the
// old value instead.)
stg_casMutVar2zh ( gcptr mv, gcptr old, gcptr new )
 /* MutVar# s a -> a -> a -> State# s -> (# State#, Int#, Any a #) */
{
    gcptr h, p;

    p = mv + SIZEOF_StgHeader + OFFSET_StgMutVar_var;
    ccall printf("Hello from CAS, loc %p, current %d, ticket %d, new %p\n", 
                 W_[p], mv, old, new);

    (h) = ccall cas(p,old, new);
    if (h != old) {
        return (1,h);
    } else {
        if (GET_INFO(mv) == stg_MUT_VAR_CLEAN_info) {
           ccall dirty_MUT_VAR(BaseReg "ptr", mv "ptr");
        }
        return (0,new);
    }
}


// The regular readMutVar# is an inline primop and would work fine for
// this EXCEPT that we need to give it a different type to prevent GHC
// from seeing the naked, lifted 'a' value (not coerced to an Any).
stg_readMutVar2zh( gcptr mv )
/*  MutVar# RealWorld a -> State# RealWorld -> (# State# RealWorld, Ticket a #) */
{
    W_ res;
    mv  = R1;
    // Do the actual read:
    res = W_[mv + SIZEOF_StgHeader + OFFSET_StgMutVar_var];
    return(res);
}

